{"meta":{"title":"逆旅","subtitle":"人生如逆旅，我亦是行人。","description":"知其白，守其黑，为天下式；","author":"未白","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-03-23T03:35:19.303Z","updated":"2021-03-23T03:35:19.302Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 | Blog"},{"title":"about","date":"2021-03-23T09:28:16.000Z","updated":"2021-04-09T07:14:35.835Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"诗， 远方， 你 我曾跨过高山，踏过河流去见你。 在路旁，看见了一枝花。 我停下了脚步， 看见了它的随风摇摆， 看见了它的哭泣， 也看见了你。"},{"title":"categories","date":"2021-03-23T09:30:01.000Z","updated":"2021-03-23T09:33:33.836Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-03-23T09:29:39.000Z","updated":"2021-03-23T09:34:48.905Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue自定义指令","slug":"Vue自定义指令","date":"2021-04-09T07:01:25.000Z","updated":"2021-04-09T10:01:53.660Z","comments":true,"path":"2021/04/09/Vue自定义指令/","link":"","permalink":"http://example.com/2021/04/09/Vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","excerpt":"Vue 自定义指令有全局注册和局部注册两种方式。先来看看注册全局指令的方式，通过Vue.directive( id, [definition] ) 方式注册全局指令。然后在入口文件中进行 Vue.use() 调用。 批量注册指令，新建 directives/index.js 文件","text":"Vue 自定义指令有全局注册和局部注册两种方式。先来看看注册全局指令的方式，通过Vue.directive( id, [definition] ) 方式注册全局指令。然后在入口文件中进行 Vue.use() 调用。 批量注册指令，新建 directives/index.js 文件 123456789101112131415import copy from &#x27;./copy&#x27;import longpress from &#x27;./longpress&#x27;// 自定义指令const directives = &#123; copy, longpress,&#125;export default &#123; install(Vue) &#123; Object.keys(directives).forEach((key) =&gt; &#123; Vue.directive(key, directives[key]) &#125;) &#125;,&#125; 在 main.js 引入并调用 123import Vue from &#x27;vue&#x27;import Directives from &#x27;./JS/directives&#x27;Vue.use(Directives) 指令定义函数提供了几个钩子函数（可选）： bind: 只调用一次，指令第一次绑定到元素时调用，可以定义一个在绑定时执行一次的初始化动作。 inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。 update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值。 componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。 unbind: 只调用一次， 指令与元素解绑时调用。 复制粘贴指令 v-copy需求：实现一键复制文本内容，用于鼠标右键粘贴。 思路： 动态创建 textarea 标签，并设置 readOnly 属性及移出可视区域 将要复制的值赋给 textarea 标签的 value 属性，并插入到 body 选中值 textarea 并复制 将 body 中插入的 textarea 移除 在第一次调用时绑定事件，在解绑时移除事件 1234567891011121314151617181920212223242526272829303132333435363738394041const copy = &#123; bind(el, &#123; value &#125;) &#123; el.$value = value el.handler = () =&gt; &#123; if (!el.$value) &#123; // 值为空的时候，给出提示。可根据项目UI仔细设计 console.log(&#x27;无复制内容&#x27;) return &#125; // 动态创建 textarea 标签 const textarea = document.createElement(&#x27;textarea&#x27;) // 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域 textarea.readOnly = &#x27;readonly&#x27; textarea.style.position = &#x27;absolute&#x27; textarea.style.left = &#x27;-9999px&#x27; // 将要 copy 的值赋给 textarea 标签的 value 属性 textarea.value = el.$value // 将 textarea 插入到 body 中 document.body.appendChild(textarea) // 选中值并复制 textarea.select() const result = document.execCommand(&#x27;Copy&#x27;) if (result) &#123; console.log(&#x27;复制成功&#x27;) // 可根据项目UI仔细设计 &#125; document.body.removeChild(textarea) &#125; // 绑定点击事件，就是所谓的一键 copy 啦 el.addEventListener(&#x27;click&#x27;, el.handler) &#125;, // 当传进来的值更新的时候触发 componentUpdated(el, &#123; value &#125;) &#123; el.$value = value &#125;, // 指令与元素解绑的时候，移除事件绑定 unbind(el) &#123; el.removeEventListener(&#x27;click&#x27;, el.handler) &#125;,&#125;export default copy 使用：给 Dom 加上 v-copy 及复制的文本即可 12345678910111213&lt;template&gt; &lt;button v-copy=&quot;copyText&quot;&gt;复制&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; copyText: &#x27;a copy directives&#x27;, &#125; &#125;, &#125;&lt;/script&gt; 长按指令 v-longpress需求：实现长按，用户需要按下并按住按钮几秒钟，触发相应的事件 思路： 创建一个计时器， 2 秒后执行函数 当用户按下按钮时触发 mousedown 事件，启动计时器；用户松开按钮时调用mouseout事件。 如果 mouseup 事件 2 秒内被触发，就清除计时器，当作一个普通的点击事件 如果计时器没有在 2 秒内清除，则判定为一次长按，可以执行关联的函数。 在移动端要考虑 touchstart，touchend 事件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const longpress = &#123; bind: function (el, binding, vNode) &#123; if (typeof binding.value !== &#x27;function&#x27;) &#123; throw &#x27;callback must be a function&#x27; &#125; // 定义变量 let pressTimer = null // 创建计时器（ 2秒后执行函数 ） let start = (e) =&gt; &#123; if (e.type === &#x27;click&#x27; &amp;&amp; e.button !== 0) &#123; return &#125; if (pressTimer === null) &#123; pressTimer = setTimeout(() =&gt; &#123; handler() &#125;, 2000) &#125; &#125; // 取消计时器 let cancel = (e) =&gt; &#123; if (pressTimer !== null) &#123; clearTimeout(pressTimer) pressTimer = null &#125; &#125; // 运行函数 const handler = (e) =&gt; &#123; binding.value(e) &#125; // 添加事件监听器 el.addEventListener(&#x27;mousedown&#x27;, start) el.addEventListener(&#x27;touchstart&#x27;, start) // 取消计时器 el.addEventListener(&#x27;click&#x27;, cancel) el.addEventListener(&#x27;mouseout&#x27;, cancel) el.addEventListener(&#x27;touchend&#x27;, cancel) el.addEventListener(&#x27;touchcancel&#x27;, cancel) &#125;, // 当传进来的值更新的时候触发 componentUpdated(el, &#123; value &#125;) &#123; el.$value = value &#125;, // 指令与元素解绑的时候，移除事件绑定 unbind(el) &#123; el.removeEventListener(&#x27;click&#x27;, el.handler) &#125;,&#125;export default longpress 使用：给 Dom 加上 v-longpress 及回调函数即可 123456789101112&lt;template&gt; &lt;button v-longpress=&quot;longpress&quot;&gt;长按&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; longpress () &#123; alert(&#x27;长按指令生效&#x27;) &#125; &#125;&#125; 输入框防抖指令 v-debounce背景：在开发中，有些提交保存按钮有时候会在短时间内被点击多次，这样就会多次重复请求后端接口，造成数据的混乱，比如新增表单的提交按钮，多次点击就会新增多条重复的数据。 需求：防止按钮在短时间内被多次点击，使用防抖函数限制规定时间内只能点击一次。 思路： 定义一个延迟执行的方法，如果在延迟时间内再调用该方法，则重新计算执行时间。 将时间绑定在 click 方法上。 123456789101112131415const debounce = &#123; inserted: function (el, binding) &#123; let timer = null; el.addEventListener(&#x27;keyup&#x27;, () =&gt; &#123; if (timer) &#123; clearTimeout(timer) &#125; timer = setTimeout(() =&gt; &#123; binding.value() &#125;, 1000) &#125;) &#125;,&#125;export default debounce 使用：给 Dom 加上 v-debounce 及回调函数即可 123456789101112&lt;template&gt; &lt;button v-debounce=&quot;debounceClick&quot;&gt;防抖&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; debounceClick () &#123; console.log(&#x27;只触发一次&#x27;) &#125; &#125;&#125; 禁止表情及特殊字符 v-emoji背景：开发中遇到的表单输入，往往会有对输入内容的限制，比如不能输入表情和特殊字符，只能输入数字或字母等。 我们常规方法是在每一个表单的 on-change 事件上做处理。 1234567891011121314&lt;template&gt; &lt;input type=&quot;text&quot; v-model=&quot;note&quot; @change=&quot;vaidateEmoji&quot; /&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; vaidateEmoji() &#123; var reg = /[^\\u4E00-\\u9FA5|\\d|\\a-zA-Z|\\r\\n\\s,.?!，。？！…—&amp;$=()-+/*&#123;&#125;[\\]]|\\s/g this.note = this.note.replace(reg, &#x27;&#x27;) &#125;, &#125;, &#125;&lt;/script&gt; 需求：根据正则表达式，设计自定义处理表单输入规则的指令，下面以禁止输入表情和特殊字符为例。 123456789101112131415161718192021222324252627282930let findEle = (parent, type) =&gt; &#123; return parent.tagName.toLowerCase() === type ? parent : parent.querySelector(type)&#125;const trigger = (el, type) =&gt; &#123; const e = document.createEvent(&#x27;HTMLEvents&#x27;) e.initEvent(type, true, true) el.dispatchEvent(e)&#125;const emoji = &#123; bind: function (el, binding, vnode) &#123; // 正则规则可根据需求自定义 var regRule = /[^\\u4E00-\\u9FA5|\\d|\\a-zA-Z|\\r\\n\\s,.?!，。？！…—&amp;$=()-+/*&#123;&#125;[\\]]|\\s/g let $inp = findEle(el, &#x27;input&#x27;) el.$inp = $inp $inp.handle = function () &#123; let val = $inp.value $inp.value = val.replace(regRule, &#x27;&#x27;) trigger($inp, &#x27;input&#x27;) &#125; $inp.addEventListener(&#x27;keyup&#x27;, $inp.handle) &#125;, unbind: function (el) &#123; el.$inp.removeEventListener(&#x27;keyup&#x27;, el.$inp.handle) &#125;,&#125;export default emoji 使用：将需要校验的输入框加上 v-emoji 即可 123&lt;template&gt; &lt;input type=&quot;text&quot; v-model=&quot;note&quot; v-emoji /&gt;&lt;/template&gt; 图片懒加载 v-LazyLoad背景：在类电商类项目，往往存在大量的图片，如 banner 广告图，菜单导航图，美团等商家列表头图等。图片众多以及图片体积过大往往会影响页面加载速度，造成不良的用户体验，所以进行图片懒加载优化势在必行。 需求：实现一个图片懒加载指令，只加载浏览器可见区域的图片。 思路： 图片懒加载的原理主要是判断当前图片是否到了可视区域这一核心逻辑实现的 拿到所有的图片 Dom ，遍历每个图片判断当前图片是否到了可视区范围内 如果到了就设置图片的 src 属性，否则显示默认图片 图片懒加载有两种方式可以实现，一是绑定 srcoll 事件进行监听，二是使用 IntersectionObserver 判断图片是否到了可视区域，但是有浏览器兼容性问题。 下面封装一个懒加载指令兼容两种方法，判断浏览器是否支持 IntersectionObserverAPI，如果支持就使用 IntersectionObserver 实现懒加载，否则则使用 srcoll 事件监听 + 节流的方法实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283const LazyLoad = &#123; // install方法 install(Vue, options) &#123; const defaultSrc = options.default Vue.directive(&#x27;lazy&#x27;, &#123; bind(el, binding) &#123; LazyLoad.init(el, binding.value, defaultSrc) &#125;, inserted(el) &#123; if (IntersectionObserver) &#123; LazyLoad.observe(el) &#125; else &#123; LazyLoad.listenerScroll(el) &#125; &#125;, &#125;) &#125;, // 初始化 init(el, val, def) &#123; el.setAttribute(&#x27;data-src&#x27;, val) el.setAttribute(&#x27;src&#x27;, def) &#125;, // 利用IntersectionObserver监听el observe(el) &#123; var io = new IntersectionObserver((entries) =&gt; &#123; const realSrc = el.dataset.src if (entries[0].isIntersecting) &#123; if (realSrc) &#123; el.src = realSrc el.removeAttribute(&#x27;data-src&#x27;) &#125; &#125; &#125;) io.observe(el) &#125;, // 监听scroll事件 listenerScroll(el) &#123; const handler = LazyLoad.throttle(LazyLoad.load, 300) LazyLoad.load(el) window.addEventListener(&#x27;scroll&#x27;, () =&gt; &#123; handler(el) &#125;) &#125;, // 加载真实图片 load(el) &#123; const windowHeight = document.documentElement.clientHeight const elTop = el.getBoundingClientRect().top const elBtm = el.getBoundingClientRect().bottom const realSrc = el.dataset.src if (elTop - windowHeight &lt; 0 &amp;&amp; elBtm &gt; 0) &#123; if (realSrc) &#123; el.src = realSrc el.removeAttribute(&#x27;data-src&#x27;) &#125; &#125; &#125;, // 节流 throttle(fn, delay) &#123; let timer let prevTime return function (...args) &#123; const currTime = Date.now() const context = this if (!prevTime) prevTime = currTime clearTimeout(timer) if (currTime - prevTime &gt; delay) &#123; prevTime = currTime fn.apply(context, args) clearTimeout(timer) return &#125; timer = setTimeout(function () &#123; prevTime = Date.now() timer = null fn.apply(context, args) &#125;, delay) &#125; &#125;,&#125;export default LazyLoad 使用，将组件内 标签的 src 换成 v-LazyLoad 1&lt;img v-LazyLoad=&quot;xxx.jpg&quot; /&gt; 补充：图片懒加载 权限校验指令 v-premission背景：在一些后台管理系统，我们可能需要根据用户角色进行一些操作权限的判断，很多时候我们都是粗暴地给一个元素添加 v-if / v-show 来进行显示隐藏，但如果判断条件繁琐且多个地方需要判断，这种方式的代码不仅不优雅而且冗余。针对这种情况，我们可以通过全局自定义指令来处理。 需求：自定义一个权限指令，对需要权限判断的 Dom 进行显示隐藏。 思路： 自定义一个权限数组 判断用户的权限是否在这个数组内，如果是则显示，否则则移除 Dom 123456789101112131415161718192021222324function checkArray(key) &#123; let arr = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;] let index = arr.indexOf(key) if (index &gt; -1) &#123; return true // 有权限 &#125; else &#123; return false // 无权限 &#125;&#125;const permission = &#123; inserted: function (el, binding) &#123; let permission = binding.value // 获取到 v-permission的值 if (permission) &#123; let hasPermission = checkArray(permission) if (!hasPermission) &#123; // 没有权限 移除Dom元素 el.parentNode &amp;&amp; el.parentNode.removeChild(el) &#125; &#125; &#125;,&#125;export default permission 使用：给 v-permission 赋值判断即可 123456&lt;div class=&quot;btns&quot;&gt; &lt;!-- 显示 --&gt; &lt;button v-permission=&quot;&#x27;1&#x27;&quot;&gt;权限按钮1&lt;/button&gt; &lt;!-- 不显示 --&gt; &lt;button v-permission=&quot;&#x27;10&#x27;&quot;&gt;权限按钮2&lt;/button&gt;&lt;/div&gt; 实现页面水印 v-waterMarker需求：给整个页面添加背景水印 思路： 使用 canvas 特性生成 base64 格式的图片文件，设置其字体大小，颜色等。 将其设置为背景图片，从而实现页面或组件水印效果 123456789101112131415161718192021222324function addWaterMarker(str, parentNode, font, textColor) &#123; // 水印文字，父元素，字体，文字颜色 var can = document.createElement(&#x27;canvas&#x27;) parentNode.appendChild(can) can.width = 200 can.height = 150 can.style.display = &#x27;none&#x27; var cans = can.getContext(&#x27;2d&#x27;) cans.rotate((-20 * Math.PI) / 180) cans.font = font || &#x27;16px Microsoft JhengHei&#x27; cans.fillStyle = textColor || &#x27;rgba(180, 180, 180, 0.3)&#x27; cans.textAlign = &#x27;left&#x27; cans.textBaseline = &#x27;Middle&#x27; cans.fillText(str, can.width / 10, can.height / 2) parentNode.style.backgroundImage = &#x27;url(&#x27; + can.toDataURL(&#x27;image/png&#x27;) + &#x27;)&#x27;&#125;const waterMarker = &#123; bind: function (el, binding) &#123; addWaterMarker(binding.value.text, el, binding.value.font, binding.value.textColor) &#125;,&#125;export default waterMarker 使用，设置水印文案，颜色，字体大小即可 123&lt;template&gt; &lt;div v-waterMarker=&quot;&#123;text:&#x27;版权所有&#x27;,textColor:&#x27;rgba(180, 180, 180, 0.4)&#x27;&#125;&quot;&gt;&lt;/div&gt;&lt;/template&gt; 拖拽指令 v-draggable需求：实现一个拖拽指令，可在页面可视区域任意拖拽元素。 思路： 设置需要拖拽的元素为相对定位，其父元素为绝对定位。 鼠标按下(onmousedown)时记录目标元素当前的 left 和 top 值。 鼠标移动(onmousemove)时计算每次移动的横向距离和纵向距离的变化值，并改变元素的 left 和 top 值 鼠标松开(onmouseup)时完成一次拖拽 123456789101112131415161718192021222324252627282930313233const draggable = &#123; inserted: function (el) &#123; el.style.cursor = &#x27;move&#x27; el.onmousedown = function (e) &#123; let disx = e.pageX - el.offsetLeft let disy = e.pageY - el.offsetTop document.onmousemove = function (e) &#123; let x = e.pageX - disx let y = e.pageY - disy let maxX = document.body.clientWidth - parseInt(window.getComputedStyle(el).width) let maxY = document.body.clientHeight - parseInt(window.getComputedStyle(el).height) if (x &lt; 0) &#123; x = 0 &#125; else if (x &gt; maxX) &#123; x = maxX &#125; if (y &lt; 0) &#123; y = 0 &#125; else if (y &gt; maxY) &#123; y = maxY &#125; el.style.left = x + &#x27;px&#x27; el.style.top = y + &#x27;px&#x27; &#125; document.onmouseup = function () &#123; document.onmousemove = document.onmouseup = null &#125; &#125; &#125;,&#125;export default draggable 使用: 在 Dom 上加上 v-draggable 即可 123&lt;template&gt; &lt;div class=&quot;el-dialog&quot; v-draggable&gt;&lt;/div&gt;&lt;/template&gt; V-Tooltip以给元素添加响应式的tooltip，并可控制显示位置、触发方式和监听事件 1npm install --save v-tooltip 补充：vue-directive-tooltip V-Money在输入框里加上货币前缀或后缀、保留小数点位数或者设置小数点符号 Github地址 12345&lt;template&gt; &lt;div&gt; &lt;input v-model.lazy=&quot;price&quot; v-money=&quot;money&quot; /&gt; &#123;&#123;price&#125;&#125; &lt;/div&gt;&lt;/template&gt; 123456789101112131415&lt;script&gt;export default &#123; data () &#123; return &#123; price: 123.45, money: &#123; decimal: &#x27;,&#x27;, thousands: &#x27;.&#x27;, prefix: &#x27;$ &#x27;, precision: 2, &#125; &#125; &#125;&#125;&lt;/script&gt; 无限滚动 Vue-Infinite-ScrollGithub地址 element-ui 同样也实现了 虚拟滚动 Vue-Virtual-Scroll组件实现方案：Alibaba Fusion Design vue-virtual-scroller 浅说虚拟列表的实现原理 「前端进阶」高性能渲染十万条数据(vue虚拟列表) 参考资料： 《分享8个非常实用的Vue自定义指令》","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"JavaScript面试知识点","slug":"JavaScript面试知识点","date":"2021-04-07T08:55:05.000Z","updated":"2021-04-08T10:03:57.286Z","comments":true,"path":"2021/04/07/JavaScript面试知识点/","link":"","permalink":"http://example.com/2021/04/07/JavaScript%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"HTML&amp;CSS 浏览器内核 盒模型、flex布局、两/三栏布局、水平/垂直居中； BFC、清除浮动； css3动画、H5新特性。 JavaScript 继承、原型链、this指向、设计模式、call, apply, bind,； new实现、防抖节流、let, var, const 区别、暂时性死区、event、loop； promise使用及实现、promise并行执行和顺序执行； async/await的优缺点； 闭包、垃圾回收和内存泄漏、数组方法、数组乱序, 数组扁平化、事件委托、事件监听、事件模型","text":"HTML&amp;CSS 浏览器内核 盒模型、flex布局、两/三栏布局、水平/垂直居中； BFC、清除浮动； css3动画、H5新特性。 JavaScript 继承、原型链、this指向、设计模式、call, apply, bind,； new实现、防抖节流、let, var, const 区别、暂时性死区、event、loop； promise使用及实现、promise并行执行和顺序执行； async/await的优缺点； 闭包、垃圾回收和内存泄漏、数组方法、数组乱序, 数组扁平化、事件委托、事件监听、事件模型 Vue vue数据双向绑定原理； vue computed原理、computed和watch的区别； vue编译器结构图、生命周期、vue组件通信； mvvm模式、mvc模式理解； vue dom diff、vuex、vue-router 网络 HTTP1, HTTP2, HTTPS、常见的http状态码； 浏览从输入网址到回车发生了什么； 前端安全（CSRF、XSS） 前端跨域、浏览器缓存、cookie, session, token, localstorage, sessionstorage； TCP连接(三次握手, 四次挥手) 性能相关 图片优化的方式 500 张图片，如何实现预加载优化 懒加载具体实现 减少http请求的方式 webpack如何配置大型项目 前端知识点：🌈Javascript的数据类型JavaScript一共有8种数据类型，其中有7种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol（es6新增，表示独一无二的值）和BigInt（es10新增）；1种引用数据类型——Object（Object本质上是由一组无序的名值对组成的）。 原始数据类型：直接存储在栈（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。 引用数据类型：同时存储在栈（stack）和堆（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 🌈数据类型的转换在 JS 中类型转换只有三种情况，分别是： 转换为布尔值（调用Boolean()方法） 转换为数字（调用Number()、parseInt()和parseFloat()方法） 转换为字符串（调用.toString()或者String()方法） 🌈数据类型的判断 typeof 除了 null 都可以显示正确的类型 12345678console.log(typeof 2); // numberconsole.log(typeof true); // booleanconsole.log(typeof &#x27;str&#x27;); // stringconsole.log(typeof []); // object []数组的数据类型在typeof 中被解释为 objectconsole.log(typeof function()&#123;&#125;); // functionconsole.log(typeof &#123;&#125;); // objectconsole.log(typeof undefined); // undefinedconsole.log(typeof null); // object null 的数据类型typeof 解释为 object instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。 12345678console.log(2 instanceof Number); // falseconsole.log(true instanceof Boolean); // false console.log(&#x27;str&#x27; instanceof String); // false console.log([] instanceof Array); // trueconsole.log(function()&#123;&#125; instanceof Function); // trueconsole.log(&#123;&#125; instanceof Object); // true // console.log(undefined instanceof Undefined);// console.log(null instanceof Null); MDN中的解释：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型（如Array）的实例，请重点关注一下是判断一个对象是否是数据类型的实例。在这里字面量值，2， true ，’str’不是实例，所以判断值为false。 内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。实现 instanceof： 首先获取类型的原型 然后获得对象的原型 然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null 1234567891011function myInstanceof(left, right) &#123; let prototype = right.prototype left = left.__proto__ while (true) &#123; if (left === null || left === undefined) return false if (prototype === left) return true left = left.__proto__ &#125;&#125; constructor 123456console.log((2).constructor === Number); // trueconsole.log((true).constructor === Boolean); // trueconsole.log((&#x27;str&#x27;).constructor === String); // trueconsole.log(([]).constructor === Array); // trueconsole.log((function() &#123;&#125;).constructor === Function); // trueconsole.log((&#123;&#125;).constructor === Object); // true 如果创建一个对象，更改它的原型，constructor就会变得不可靠 123456function Fn()&#123;&#125;;Fn.prototype=new Array();var f=new Fn(); console.log(f.constructor===Fn); // falseconsole.log(f.constructor===Array); // true **Object.prototype.toString.call() ** 使用 Object 对象的原型方法 toString 12345678910var a = Object.prototype.toString; console.log(a.call(2));console.log(a.call(true));console.log(a.call(&#x27;str&#x27;));console.log(a.call([]));console.log(a.call(function()&#123;&#125;));console.log(a.call(&#123;&#125;));console.log(a.call(undefined));console.log(a.call(null)); 🌈Javascript的内置对象内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函 数对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556全局的对象（ global objects ）或称标准内置对象，不要和 &quot;全局对象（global object）&quot; 混淆。这里说的全局的对象是说在全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。标准内置对象的分类（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date（5）字符串，用来表示和操作字符串的对象。例如 String、RegExp（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。例如 Map、Set、WeakMap、WeakSet（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。例如 SIMD 等（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等（10）控制抽象对象例如 Promise、Generator 等（11）反射例如 Reflect、Proxy（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等（13）WebAssembly（14）其他例如 arguments 🌈undefined 与 undeclared已在作用域中声明但还没有赋值的变量，是 undefined。相反，还没有在作用域中声明过的变量，是 undeclared 的。 对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是可以使用 typeof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 “undefined”。 🌈null 与 undefinedUndefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。 undefined 代表的含义是未定义， null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null 主要用于赋值给一些可能会返回对象的变量，作为初始化。 undefined 在 js 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它会影响对 undefined 值的判断。但是可以通过一些方法获得安全的 undefined 值，比如说 void 0。 🌈{}和[]的valueOf和toString的结果123&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot; 🎈Javascript 的作用域和作用域链作用域： 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。 作用域链： 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和 函数。 作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前 端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。 当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。 作用域链的创建过程跟执行上下文的建立有关…. 🎈Javascript 创建对象方式123456789101112131415我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象创建方式，我了解到的方式有这么几种：（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。 🎈Javascript 继承的实现方式123456789101112131415161718192021222324252627282930313233343536我了解的 js 中实现继承的几种方式有：（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。// 寄生式组合继承的实现function Person(name) &#123; this.name = name;&#125;Person.prototype.sayName = function() &#123; console.log(&quot;My name is &quot; + this.name + &quot;.&quot;);&#125;;function Student(name, grade) &#123; Person.call(this, name); this.grade = grade;&#125;Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;Student.prototype.sayMyGrade = function() &#123; console.log(&quot;My grade is &quot; + this.grade + &quot;.&quot;); &#125;; 🎈this、call、apply和bind的理解 在浏览器里，在全局范围内this 指向window对象； 在函数中，this永远指向最后调用他的那个对象； 构造函数中，this指向new出来的那个新的对象； call、apply、bind中的this被强绑定在指定的那个对象上； 箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来； apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。 🎈JavaScript 原型，原型链, 有什么特点？使用构造函数来新建一个对象，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部 将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们 是不应该能够获取到这个值的，但是现在浏览器中都实现了 proto 属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对象的原型。 当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。 特点： JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与 之相关的对象也会继承这一改变。 // 获取原型的方法 p.proto p.constructor.prototype Object.getPrototypeOf(p) 🎈闭包闭包是指有权访问另一个函数作用域内变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。 闭包有两个常用的用途。 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。 1234567891011function a()&#123; var n = 0; function add()&#123; n++; console.log(n); &#125; return add;&#125;var a1 = a(); //注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；a1(); //1a1(); //2 第二次调用n变量还在内存中 🌈DOM 和 BOMDOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。 BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM 的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局） 对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati on 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对 象的子对象。 🌈三种事件模型和事件委托事件 是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。 DOM0级模型： 这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js属性来指定监听函数。这种方式是所有浏览器都兼容的。 IE 事件模型： 在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。 DOM2 级事件模型： 在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。 事件委托 本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。 使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。 🌈创建一个 Ajax创建步骤： 123456789101112// 原生写法//1：创建Ajax对象var xhr = window.XMLHttpRequest?new XMLHttpRequest():new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;);// 兼容IE6及以下版本//2：配置 Ajax请求地址xhr.open(&#x27;get&#x27;,&#x27;index.xml&#x27;,true);//3：发送请求xhr.send(null); // 严谨写法//4:监听请求，接受响应xhr.onreadysatechange=function()&#123; if(xhr.readySate==4&amp;&amp;xhr.status==200 || xhr.status==304 ) console.log(xhr.responsetXML)&#125; 123456789101112131415// jquery $.ajax(&#123; type:&#x27;post&#x27;, url:&#x27;&#x27;, async:ture,//async 异步 sync 同步 data:data,//针对post请求 dataType:&#x27;jsonp&#x27;, success:function (msg) &#123; &#125;, error:function (error) &#123; &#125;&#125;) 123456789101112131415161718192021222324252627282930313233343536373839// promise 封装实现：function getJSON(url) &#123; // 创建一个 promise 对象 let promise = new Promise(function(resolve, reject) &#123; let xhr = new XMLHttpRequest(); // 新建一个 http 请求 xhr.open(&quot;GET&quot;, url, true); // 设置状态的监听函数 xhr.onreadystatechange = function() &#123; if (this.readyState !== 4) return; // 当请求成功或失败时，改变 promise 的状态 if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; // 设置错误监听函数 xhr.onerror = function() &#123; reject(new Error(this.statusText)); &#125;; // 设置响应的数据类型 xhr.responseType = &quot;json&quot;; // 设置请求头信息 xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;); // 发送 http 请求 xhr.send(null); &#125;); return promise;&#125; 🌈Javascript 的几种模块规范现在比较成熟的有四种模块加载方案： 第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。 第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。 第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。 第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。 AMD 和 CMD 规范的区别： 第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。 第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。 123456789101112131415161718// CMDdefine(function(require, exports, module) &#123; var a = require(&quot;./a&quot;); a.doSomething(); // 此处略去 100 行 var b = require(&quot;./b&quot;); // 依赖可以就近书写 b.doSomething(); // ...&#125;);// AMD 默认推荐define([&quot;./a&quot;, &quot;./b&quot;], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething(); // 此处略去 100 行 b.doSomething(); // ...&#125;); ES6 模块与 CommonJS 模块、require.js CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。 🎈Javascript的运行机制事件循环： js代码执行过程中会有很多任务，这些任务总的分成两类： 同步任务 异步任务 当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 那主线程执行栈何时为空呢？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 以上就是js运行的整体流程 需要注意的是除了同步任务和异步任务，任务还可以更加细分为macrotask(宏任务)和microtask(微任务)，js引擎会优先执行微任务 微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。 宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。 首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。 在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务 当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。 任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。 当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。 123456789101112131415setTimeout(function() &#123; console.log(1)&#125;, 0);new Promise(function(resolve, reject) &#123; console.log(2); resolve()&#125;).then(function() &#123; console.log(3)&#125;);process.nextTick(function () &#123; console.log(4)&#125;)console.log(5)// 2 5 4 3 1 第一轮：主线程开始执行，遇到setTimeout，将setTimeout的回调函数丢到宏任务队列中，在往下执行new Promise立即执行，输出2，then的回调函数丢到微任务队列中，再继续执行，遇到process.nextTick，同样将回调函数扔到为任务队列，再继续执行，输出5，当所有同步任务执行完成后看有没有可以执行的微任务，发现有then函数和nextTick两个微任务，先执行哪个呢？process.nextTick指定的异步任务总是发生在所有异步任务之前，因此先执行process.nextTick输出4然后执行then函数输出3，第一轮执行结束。第二轮：从宏任务队列开始，发现setTimeout回调，输出1执行完毕，因此结果是25431 🌈V8 引擎的垃圾回收机制 v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。 新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。 新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步： （1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。 （2）如果对象不存活，则释放对象的空间。 （3）最后将 From 空间和 To 空间角色进行交换。 新生代对象晋升到老生代有两个条件： （1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。 （2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。 老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以为了解决内存碎片的问题引入了标记压缩法。 由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。 🎈Javascript深浅拷贝 浅拷贝： 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。 深拷贝： 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。 浅拷贝的实现方式： Object.assign() 方法： 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 Array.prototype.slice()：slice() 方法返回一个新的数组对象，这一对象是一个由 begin和end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。 拓展运算符...： 123456789let a = &#123; name: &quot;Jake&quot;, flag: &#123; title: &quot;better day by day&quot;, time: &quot;2020-05-31&quot; &#125;&#125;let b = &#123;...a&#125;; 深拷贝的实现方式： 乞丐版： JSON.parse(JSON.stringify(object))，缺点诸多（会忽略undefined、symbol、函数；不能解决循环引用；不能处理正则、new Date()） 基础版（面试够用）： 浅拷贝+递归 （只考虑了普通的 object和 array两种数据类型） 12345678910111213141516function cloneDeep(target,map = new WeakMap()) &#123; if(typeOf taret ===&#x27;object&#x27;)&#123; let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;; if(map.get(target)) &#123; return target; &#125; map.set(target, cloneTarget); for(const key in target)&#123; cloneTarget[key] = cloneDeep(target[key], map); &#125; return cloneTarget &#125;else&#123; return target &#125;&#125; 终极版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147const mapTag = &#x27;[object Map]&#x27;;const setTag = &#x27;[object Set]&#x27;;const arrayTag = &#x27;[object Array]&#x27;;const objectTag = &#x27;[object Object]&#x27;;const argsTag = &#x27;[object Arguments]&#x27;;const boolTag = &#x27;[object Boolean]&#x27;;const dateTag = &#x27;[object Date]&#x27;;const numberTag = &#x27;[object Number]&#x27;;const stringTag = &#x27;[object String]&#x27;;const symbolTag = &#x27;[object Symbol]&#x27;;const errorTag = &#x27;[object Error]&#x27;;const regexpTag = &#x27;[object RegExp]&#x27;;const funcTag = &#x27;[object Function]&#x27;;const deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];function forEach(array, iteratee) &#123; let index = -1; const length = array.length; while (++index &lt; length) &#123; iteratee(array[index], index); &#125; return array;&#125;function isObject(target) &#123; const type = typeof target; return target !== null &amp;&amp; (type === &#x27;object&#x27; || type === &#x27;function&#x27;);&#125;function getType(target) &#123; return Object.prototype.toString.call(target);&#125;function getInit(target) &#123; const Ctor = target.constructor; return new Ctor();&#125;function cloneSymbol(targe) &#123; return Object(Symbol.prototype.valueOf.call(targe));&#125;function cloneReg(targe) &#123; const reFlags = /\\w*$/; const result = new targe.constructor(targe.source, reFlags.exec(targe)); result.lastIndex = targe.lastIndex; return result;&#125;function cloneFunction(func) &#123; const bodyReg = /(?&lt;=&#123;)(.|\\n)+(?=&#125;)/m; const paramReg = /(?&lt;=\\().+(?=\\)\\s+&#123;)/; const funcString = func.toString(); if (func.prototype) &#123; const param = paramReg.exec(funcString); const body = bodyReg.exec(funcString); if (body) &#123; if (param) &#123; const paramArr = param[0].split(&#x27;,&#x27;); return new Function(...paramArr, body[0]); &#125; else &#123; return new Function(body[0]); &#125; &#125; else &#123; return null; &#125; &#125; else &#123; return eval(funcString); &#125;&#125;function cloneOtherType(targe, type) &#123; const Ctor = targe.constructor; switch (type) &#123; case boolTag: case numberTag: case stringTag: case errorTag: case dateTag: return new Ctor(targe); case regexpTag: return cloneReg(targe); case symbolTag: return cloneSymbol(targe); case funcTag: return cloneFunction(targe); default: return null; &#125;&#125;function clone(target, map = new WeakMap()) &#123; // 克隆原始类型 if (!isObject(target)) &#123; return target; &#125; // 初始化 const type = getType(target); let cloneTarget; if (deepTag.includes(type)) &#123; cloneTarget = getInit(target, type); &#125; else &#123; return cloneOtherType(target, type); &#125; // 防止循环引用 if (map.get(target)) &#123; return map.get(target); &#125; map.set(target, cloneTarget); // 克隆set if (type === setTag) &#123; target.forEach(value =&gt; &#123; cloneTarget.add(clone(value, map)); &#125;); return cloneTarget; &#125; // 克隆map if (type === mapTag) &#123; target.forEach((value, key) =&gt; &#123; cloneTarget.set(key, clone(value, map)); &#125;); return cloneTarget; &#125; // 克隆对象和数组 const keys = type === arrayTag ? undefined : Object.keys(target); forEach(keys || target, (value, key) =&gt; &#123; if (keys) &#123; key = value; &#125; cloneTarget[key] = clone(target[key], map); &#125;); return cloneTarget;&#125;module.exports = &#123; clone&#125;; 🎈函数柯里化12345678910111213141516171819202122232425262728293031// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。function curry(fn, args) &#123; // 获取函数需要的参数长度 let length = fn.length; args = args || []; return function() &#123; let subArgs = args.slice(0); // 拼接得到现有的所有参数 for (let i = 0; i &lt; arguments.length; i++) &#123; subArgs.push(arguments[i]); &#125; // 判断参数的长度是否已经满足函数所需参数的长度 if (subArgs.length &gt;= length) &#123; // 如果满足，执行函数 return fn.apply(this, subArgs); &#125; else &#123; // 如果不满足，递归返回科里化的函数，等待参数的传入 return curry.call(this, fn, subArgs); &#125; &#125;;&#125;// es6 实现function curry(fn, ...args) &#123; return fn.length &lt;= args.length ? fn(...args) : curry.bind(null, fn, ...args);&#125; 🎈new操作符new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。new 关键字会进行如下的操作： 创建一个空的简单JavaScript对象（即{}）； 链接该对象（即设置该对象的构造函数）到另一个对象 ； 将步骤1新创建的对象作为this的上下文 ； 如果该函数没有返回对象，则返回this。 12345678910111213141516171819202122232425262728function Dog(name, color, age) &#123; this.name = name; this.color = color; this.age = age;&#125;Dog.prototype=&#123; getName: function() &#123; return this.name &#125;&#125;var dog = new Dog(&#x27;大白&#x27;, &#x27;yellow&#x27;, 3)// 第一步：创建一个简单空对象var obj = &#123;&#125;// 第二步：链接该对象到另一个对象（原型链）obj.__proto__ = Dog.prototype // 设置原型链 // 第三步：将步骤1新创建的对象作为 this 的上下文Dog.apply(obj, [&#x27;大白&#x27;, &#x27;yellow&#x27;, 3]) // this指向obj对象// 第四步：如果该函数没有返回对象，则返回this// 因为 Dog() 没有返回值，所以返回objvar dog = objdog.getName() 1234567891011function objectFactory()&#123; var obj = &#123;&#125;; //取得该方法的第一个参数(并删除第一个参数)，该参数是构造函数 var Constructor = [].shift.apply(arguments); //将新对象的内部属性__proto__指向构造函数的原型，这样新对象就可以访问原型中的属性和方法 obj.__proto__ = Constructor.prototype; //取得构造函数的返回值 var ret = Constructor.apply(obj, arguments); //如果返回值是一个对象就返回该对象，否则返回构造函数的一个实例对象 return typeof ret === &quot;object&quot; ? ret : obj;&#125; 🎈Promise，手写实现Promise，翻译过来是承诺，承诺它过一段时间会给你一个结果。从编程讲Promise 是异步编程的一种解决方案。下面是Promise在MDN的相关说明： Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象。 一个 Promise有以下几种状态: pending: 初始状态，既不是成功，也不是失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 fulfilled/rejected 后，就不能再次改变。 1234567891011121314151617new Promise((resolve，reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(1) resolve() &#125;,1000) &#125;).then((res) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(2) &#125;,2000)&#125;).then((res) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(3) &#125;,3000)&#125;).catch((err) =&gt; &#123;console.log(err)&#125;) promise手写实现： 123456789101112131415161718192021222324252627282930313233343536373839function myPromise(constructor)&#123; let self=this; self.status=&quot;pending&quot; //定义状态改变前的初始状态 self.value=undefined;//定义状态为resolved的时候的状态 self.reason=undefined;//定义状态为rejected的时候的状态 function resolve(value)&#123; //两个===&quot;pending&quot;，保证了状态的改变是不可逆的 if(self.status===&quot;pending&quot;)&#123; self.value=value; self.status=&quot;resolved&quot;; &#125; &#125; function reject(reason)&#123; //两个===&quot;pending&quot;，保证了状态的改变是不可逆的 if(self.status===&quot;pending&quot;)&#123; self.reason=reason; self.status=&quot;rejected&quot;; &#125; &#125; //捕获构造异常 try&#123; constructor(resolve,reject); &#125;catch(e)&#123; reject(e); &#125;&#125;// 定义链式调用的then方法myPromise.prototype.then=function(onFullfilled,onRejected)&#123; let self=this; switch(self.status)&#123; case &quot;resolved&quot;: onFullfilled(self.value); break; case &quot;rejected&quot;: onRejected(self.reason); break; default: &#125;&#125; 🎈Iterator 与 Generator函数Iterator（迭代器）是一种接口，也可以说是一种规范。为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 123const obj &#x3D; &#123; [Symbol.iterator]:function()&#123;&#125;&#125; [Symbol.iterator] 属性名是固定的写法，只要拥有了该属性的对象，就能够用迭代器的方式进行遍历。 迭代器的遍历方法是首先获得一个迭代器的指针，初始时该指针指向第一条数据之前，接着通过调用 next 方法，改变指针的指向，让其指向下一条数据 每一次的 next 都会返回一个对象，该对象有两个属性 value 代表想要获取的数据 done 布尔值，false表示当前指针指向的数据有值，true表示遍历已经结束 Iterator 的作用有三个： 为各种数据结构，提供一个统一的、简便的访问接口； 使得数据结构的成员能够按某种次序排列； ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。 遍历过程： 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 不断调用指针对象的next方法，直到它指向数据结构的结束位置。 每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。 123456let arr = [&#123;num:1&#125;,2,3]let it = arr[Symbol.iterator]() // 获取数组中的迭代器console.log(it.next()) // &#123; value: Object &#123; num: 1 &#125;, done: false &#125;console.log(it.next()) // &#123; value: 2, done: false &#125;console.log(it.next()) // &#123; value: 3, done: false &#125;console.log(it.next()) // &#123; value: undefined, done: true &#125; Generator函数可以说是Iterator接口的具体实现方式。Generator 最大的特点就是可以控制函数的执行。 123456789function *foo(x) &#123; let y = 2 * (yield (x + 1)) let z = yield (y / 3) return (x + y + z)&#125;let it = foo(5)console.log(it.next()) // =&gt; &#123;value: 6, done: false&#125;console.log(it.next(12)) // =&gt; &#123;value: 8, done: false&#125;console.log(it.next(13)) // =&gt; &#123;value: 42, done: true&#125; 上面这个示例就是一个Generator函数，我们来分析其执行过程： 首先 Generator 函数调用时它会返回一个迭代器 当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6 当执行第二次 next 时，传入的参数等于上一个 yield 的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 yield 等于 2 * 12 / 3 = 8 当执行第三次 next 时，传入的参数会传递给 z，所以 z = 13, x = 5, y = 24，相加等于 42 🎈async/awaitasync/await是一种建立在Promise之上的编写异步或非阻塞代码的新方法，被普遍认为是 JS异步操作的最终且最优雅的解决方案。相对于 Promise 和回调，它的可读性和简洁度都更高。毕竟一直then()也很烦。 async 是异步的意思，而 await 是 async wait的简写，即异步等待。 所以从语义上就很好理解 async 用于声明一个 function 是异步的，而await 用于等待一个异步方法执行完成。 一个函数如果加上 async ，那么该函数就会返回一个 Promise 1234async function test() &#123; return &quot;1&quot;&#125;console.log(test()) // -&gt; Promise &#123;&lt;resolved&gt;: &quot;1&quot;&#125; async 函数返回的是一个 Promise 对象，如果在 async 函数中直接 return 一个直接量，async 会把这个直接量通过 PromIse.resolve() 封装成Promise对象返回。 相比于 Promise，async/await能更好地处理 then 链 1234567891011121314151617181920function takeLongTime(n) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(n + 200), n); &#125;);&#125;function step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step2(n) &#123; console.log(`step2 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step3(n) &#123; console.log(`step3 with $&#123;n&#125;`); return takeLongTime(n);&#125; 使用Promise 123456789101112131415function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; step1(time1) .then(time2 =&gt; step2(time2)) .then(time3 =&gt; step3(time3)) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`); &#125;);&#125;doIt();// step1 with 300// step2 with 500// step3 with 700// result is 900 使用async/await 123456789async function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time2); const result = await step3(time3); console.log(`result is $&#123;result&#125;`);&#125;doIt(); await关键字只能在async function中使用。在任何非async function的函数中使用await关键字都会抛出错误。await关键字在执行下一行代码之前等待右侧表达式(可能是一个Promise)返回。 优缺点： async/await的优势在于处理 then 的调用链，能够更清晰准确的写出代码，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。 🎈Javascript节流与防抖函数防抖 是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。 函数节流 是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。 12345678910111213141516171819202122232425262728293031323334353637// 函数防抖的实现function debounce(fn, wait) &#123; var timer = null; return function() &#123; var context = this, args = arguments; // 如果此时存在定时器的话，则取消之前的定时器重新记时 if (timer) &#123; clearTimeout(timer); timer = null; &#125; // 设置定时器，使事件间隔指定事件后执行 timer = setTimeout(() =&gt; &#123; fn.apply(context, args); &#125;, wait); &#125;;&#125;// 函数节流的实现;function throttle(fn, delay) &#123; var preTime = Date.now(); return function() &#123; var context = this, args = arguments, nowTime = Date.now(); // 如果两次时间间隔超过了指定时间，则执行函数。 if (nowTime - preTime &gt;= delay) &#123; preTime = Date.now(); return fn.apply(context, args); &#125; &#125;;&#125; 🎈设计模式概念设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。 设计原则 S – Single Responsibility Principle 单一职责原则 一个程序只做好一件事 如果功能过于复杂就拆分开，每个部分保持独立 O – OpenClosed Principle 开放/封闭原则 对扩展开放，对修改封闭 增加需求时，扩展新代码，而非修改已有代码 L – Liskov Substitution Principle 里氏替换原则 子类能覆盖父类 父类能出现的地方子类就能出现 I – Interface Segregation Principle 接口隔离原则 保持接口的单一独立 类似单一职责原则，这里更关注接口 D – Dependency Inversion Principle 依赖倒转原则 面向接口编程，依赖于抽象而不依赖于具 使用方只关注接口而不关注具体类的实现 设计模式的类型 结构型模式（Structural Patterns）： 通过识别系统中组件间的简单关系来简化系统的设计。 创建型模式（Creational Patterns）： 处理对象的创建，根据实际情况使用合适的方式创建对象。常规的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。 行为型模式（Behavioral Patterns）： 用于识别对象之间常见的交互模式并加以实现，如此，增加了这些交互的灵活性。 9种前端常见的设计模式1. 外观模式（Facade Pattern） 外观模式是最常见的设计模式之一，它为子系统中的一组接口提供一个统一的高层接口，使子系统更容易使用。简而言之外观设计模式就是把多个子系统中复杂逻辑进行抽象，从而提供一个更统一、更简洁、更易用的API。很多我们常用的框架和库基本都遵循了外观设计模式，比如JQuery就把复杂的原生DOM操作进行了抽象和封装，并消除了浏览器之间的兼容问题，从而提供了一个更高级更易用的版本。其实在平时工作中我们也会经常用到外观模式进行开发，只是我们不自知而已。 兼容浏览器事件绑定 123456789let addMyEvent = function (el, ev, fn) &#123; if (el.addEventListener) &#123; el.addEventListener(ev, fn, false) &#125; else if (el.attachEvent) &#123; el.attachEvent(&#x27;on&#x27; + ev, fn) &#125; else &#123; el[&#x27;on&#x27; + ev] = fn &#125;&#125;; 封装接口 1234567let myEvent = &#123; // ... stop: e =&gt; &#123; e.stopPropagation(); e.preventDefault(); &#125;&#125;; 场景 设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观Facade 在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观Facade可以提供一个简单的接口，减少他们之间的依赖。 在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观Facade也是非常合适的，为系系统开发一个外观Facade类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和Facade对象交互，Facade与遗留代码交互所有的复杂工作。 优点 减少系统相互依赖。 提高灵活性。 提高了安全性 缺点 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。 2. 代理模式（Proxy Pattern） 是为一个对象提供一个代用品或占位符，以便控制对它的访问 假设当A 在心情好的时候收到花，小明表白成功的几率有 60%，而当A 在心情差的时候收到花，小明表白的成功率无限趋近于0。小明跟A 刚刚认识两天，还无法辨别A 什么时候心情好。如果不合时宜地把花送给A，花 被直接扔掉的可能性很大，这束花可是小明吃了7 天泡面换来的。但是A 的朋友B 却很了解A，所以小明只管把花交给B，B 会监听A 的心情变化，然后选 择A 心情好的时候把花转交给A，代码如下： 12345678910111213141516171819202122232425let Flower = function() &#123;&#125;let xiaoming = &#123; sendFlower: function(target) &#123; let flower = new Flower() target.receiveFlower(flower) &#125;&#125;let B = &#123; receiveFlower: function(flower) &#123; A.listenGoodMood(function() &#123; A.receiveFlower(flower) &#125;) &#125;&#125;let A = &#123; receiveFlower: function(flower) &#123; console.log(&#x27;收到花&#x27;+ flower) &#125;, listenGoodMood: function(fn) &#123; setTimeout(function() &#123; fn() &#125;, 1000) &#125;&#125;xiaoming.sendFlower(B) 场景 HTML元 素事件代理 1234567891011&lt;ul id=&quot;ul&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; let ul = document.querySelector(&#x27;#ul&#x27;); ul.addEventListener(&#x27;click&#x27;, event =&gt; &#123; console.log(event.target); &#125;);&lt;/script&gt; ES6 的 proxy 阮一峰Proxy jQuery.proxy()方法 优点 代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用 代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则； 缺点 处理请求速度可能有差别，非直接访问存在开销 3. 工厂模式（Factory Pattern） 工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。 1234567891011121314151617181920212223class Product &#123; constructor(name) &#123; this.name = name &#125; init() &#123; console.log(&#x27;init&#x27;) &#125; fun() &#123; console.log(&#x27;fun&#x27;) &#125;&#125;class Factory &#123; create(name) &#123; return new Product(name) &#125;&#125;// uselet factory = new Factory()let p = factory.create(&#x27;p1&#x27;)p.init()p.fun() 场景 如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择 将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式； 需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性 优点 创建对象的过程可能很复杂，但我们只需要关心创建结果。 构造函数和创建者分离, 符合“开闭原则” 一个调用者想创建一个对象，只要知道其名称就可以了。 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 缺点 添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度 考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度 什么时候不用 当被应用到错误的问题类型上时,这一模式会给应用程序引入大量不必要的复杂性.除非为创建对象提供一个接口是我们编写的库或者框架的一个设计上目标,否则我会建议使用明确的构造器,以避免不必要的开销。 由于对象的创建过程被高效的抽象在一个接口后面的事实,这也会给依赖于这个过程可能会有多复杂的单元测试带来问题。 4. 单例模式（Singleton Pattern） 顾名思义，单例模式中Class的实例个数最多为1。当需要一个对象去贯穿整个系统执行某些任务时，单例模式就派上了用场。而除此之外的场景尽量避免单例模式的使用，因为单例模式会引入全局状态，而一个健康的系统应该避免引入过多的全局状态。 实现单例模式需要解决以下几个问题： 如何确定Class只有一个实例？ 如何简便的访问Class的唯一实例？ Class如何控制实例化的过程？ 如何将Class的实例个数限制为1？ 我们一般通过实现以下两点来解决上述问题： 隐藏Class的构造函数，避免多次实例化 通过暴露一个 getInstance() 方法来创建/获取唯一实例 Javascript中单例模式可以通过以下方式实现： 123456789101112131415161718// 单例构造器const FooServiceSingleton = (function () &#123; // 隐藏的Class的构造函数 function FooService() &#123;&#125; // 未初始化的单例对象 let fooService; return &#123; // 创建/获取单例对象的函数 getInstance: function () &#123; if (!fooService) &#123; fooService = new FooService(); &#125; return fooService; &#125; &#125;&#125;)(); 实现的关键点有： 使用 IIFE创建局部作用域并即时执行； getInstance() 为一个 闭包 ，使用闭包保存局部作用域中的单例对象并返回。 我们可以验证下单例对象是否创建成功： 1234const fooService1 = FooServiceSingleton.getInstance();const fooService2 = FooServiceSingleton.getInstance();console.log(fooService1 === fooService2); // true 场景例子 定义命名空间和实现分支型方法 登录框 vuex 和 redux中的store 优点 划分命名空间，减少全局变量 增强模块性，把自己的代码组织在一个全局变量名下，放在单一位置，便于维护 且只会实例化一次。简化了代码的调试和维护 缺点 由于单例模式提供的是一种单点访问，所以它有可能导致模块间的强耦合 从而不利于单元测试。无法单独测试一个调用了来自单例的方法的类，而只能把它与那个单例作为一 个单元一起测试。 5. 策略模式（Strategy Pattern） 策略模式简单描述就是：对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。把它们一个个封装起来，并且使它们可以互相替换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;html&gt;&lt;head&gt; &lt;title&gt;策略模式-校验表单&lt;/title&gt; &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;form id = &quot;registerForm&quot; method=&quot;post&quot; action=&quot;http://xxxx.com/api/register&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; 手机号码：&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot;&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 策略对象 const strategies = &#123; isNoEmpty: function (value, errorMsg) &#123; if (value === &#x27;&#x27;) &#123; return errorMsg; &#125; &#125;, isNoSpace: function (value, errorMsg) &#123; if (value.trim() === &#x27;&#x27;) &#123; return errorMsg; &#125; &#125;, minLength: function (value, length, errorMsg) &#123; if (value.trim().length &lt; length) &#123; return errorMsg; &#125; &#125;, maxLength: function (value, length, errorMsg) &#123; if (value.length &gt; length) &#123; return errorMsg; &#125; &#125;, isMobile: function (value, errorMsg) &#123; if (!/^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|17[7]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$/.test(value)) &#123; return errorMsg; &#125; &#125; &#125; // 验证类 class Validator &#123; constructor() &#123; this.cache = [] &#125; add(dom, rules) &#123; for(let i = 0, rule; rule = rules[i++];) &#123; let strategyAry = rule.strategy.split(&#x27;:&#x27;) let errorMsg = rule.errorMsg this.cache.push(() =&gt; &#123; let strategy = strategyAry.shift() strategyAry.unshift(dom.value) strategyAry.push(errorMsg) return strategies[strategy].apply(dom, strategyAry) &#125;) &#125; &#125; start() &#123; for(let i = 0, validatorFunc; validatorFunc = this.cache[i++];) &#123; let errorMsg = validatorFunc() if (errorMsg) &#123; return errorMsg &#125; &#125; &#125; &#125; // 调用代码 let registerForm = document.getElementById(&#x27;registerForm&#x27;) let validataFunc = function() &#123; let validator = new Validator() validator.add(registerForm.userName, [&#123; strategy: &#x27;isNoEmpty&#x27;, errorMsg: &#x27;用户名不可为空&#x27; &#125;, &#123; strategy: &#x27;isNoSpace&#x27;, errorMsg: &#x27;不允许以空白字符命名&#x27; &#125;, &#123; strategy: &#x27;minLength:2&#x27;, errorMsg: &#x27;用户名长度不能小于2位&#x27; &#125;]) validator.add(registerForm.password, [ &#123; strategy: &#x27;minLength:6&#x27;, errorMsg: &#x27;密码长度不能小于6位&#x27; &#125;]) validator.add(registerForm.phoneNumber, [&#123; strategy: &#x27;isMobile&#x27;, errorMsg: &#x27;请输入正确的手机号码格式&#x27; &#125;]) return validator.start() &#125; registerForm.onsubmit = function() &#123; let errorMsg = validataFunc() if (errorMsg) &#123; alert(errorMsg) return false &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 场景例子 如果在一个系统里面有许多类，它们之间的区别仅在于它们的’行为’，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 一个系统需要动态地在几种算法中选择一种。 表单验证 优点 利用组合、委托、多态等技术和思想，可以有效的避免多重条件选择语句 提供了对开放-封闭原则的完美支持，将算法封装在独立的strategy中，使得它们易于切换，理解，易于扩展 利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的代替方案 缺点 会在程序中增加许多策略类或者策略对象 要使用策略模式，必须了解所有的strategy，必须了解各个strategy之间的不同点，这样才能选择一个合适的strategy 6. 迭代器模式（Iterator Pattern） 迭代器模式简单的说就是提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象的内部表示。 迭代器模式解决了以下问题： 提供一致的遍历各种数据结构的方式，而不用了解数据的内部结构 提供遍历容器（集合）的能力而无需改变容器的接口 一个迭代器通常需要实现以下接口： hasNext()：判断迭代是否结束，返回Boolean next()：查找并返回下一个元素 为Javascript的数组实现一个迭代器可以这么写： 123456789101112131415const item = [1, &#x27;red&#x27;, false, 3.14];function Iterator(items) &#123; this.items = items; this.index = 0;&#125;Iterator.prototype = &#123; hasNext: function () &#123; return this.index &lt; this.items.length; &#125;, next: function () &#123; return this.items[this.index++]; &#125;&#125; 验证一下迭代器是否工作： 123456const iterator = new Iterator(item);while(iterator.hasNext())&#123; console.log(iterator.next());&#125;//输出：1, red, false, 3.14 ES6提供了更简单的迭代循环语法 for…of，使用该语法的前提是操作对象需要实现 可迭代协议（The iterable protocol），简单说就是该对象有个Key为 Symbol.iterator 的方法，该方法返回一个iterator对象。 比如我们实现一个 Range 类用于在某个数字区间进行迭代： 1234567891011121314function Range(start, end) &#123; return &#123; [Symbol.iterator]: function () &#123; return &#123; next() &#123; if (start &lt; end) &#123; return &#123; value: start++, done: false &#125;; &#125; return &#123; done: true, value: end &#125;; &#125; &#125; &#125; &#125;&#125; 验证一下： 1234for (num of Range(1, 5)) &#123; console.log(num);&#125;// 输出：1, 2, 3, 4 7. 观察者模式（Observer Pattern） 观察者模式又称发布-订阅模式（Publish/Subscribe Pattern），是我们经常接触到的设计模式，日常生活中的应用也比比皆是，比如你订阅了某个博主的频道，当有内容更新时会收到推送；又比如JavaScript中的事件订阅响应机制。观察者模式的思想用一句话描述就是：被观察对象（subject）维护一组观察者（observer），当被观察对象状态改变时，通过调用观察者的某个方法将这些变化通知到观察者。 观察者模式中Subject对象一般需要实现以下API： subscribe(): 接收一个观察者observer对象，使其订阅自己 unsubscribe(): 接收一个观察者observer对象，使其取消订阅自己 fire(): 触发事件，通知到所有观察者 用JavaScript手动实现观察者模式： 1234567891011121314151617181920212223// 被观察者function Subject() &#123; this.observers = [];&#125;Subject.prototype = &#123; // 订阅 subscribe: function (observer) &#123; this.observers.push(observer); &#125;, // 取消订阅 unsubscribe: function (observerToRemove) &#123; this.observers = this.observers.filter(observer =&gt; &#123; return observer !== observerToRemove; &#125;) &#125;, // 事件触发 fire: function () &#123; this.observers.forEach(observer =&gt; &#123; observer.call(); &#125;); &#125;&#125; 验证一下订阅是否成功： 123456789101112131415161718const subject = new Subject();function observer1() &#123; console.log(&#x27;Observer 1 Firing!&#x27;);&#125;function observer2() &#123; console.log(&#x27;Observer 2 Firing!&#x27;);&#125;subject.subscribe(observer1);subject.subscribe(observer2);subject.fire();//输出：Observer 1 Firing! Observer 2 Firing! 验证一下取消订阅是否成功： 12345subject.unsubscribe(observer2);subject.fire();//输出：Observer 1 Firing! 场景 DOM事件 1234document.body.addEventListener(&#x27;click&#x27;, function() &#123; console.log(&#x27;hello world!&#x27;);&#125;);document.body.click() vue 响应式 优点 支持简单的广播通信，自动通知所有已经订阅过的对象 目标对象与观察者之间的抽象耦合关系能单独扩展以及重用 增加了灵活性 观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。 缺点 过度使用会导致对象与对象之间的联系弱化，会导致程序难以跟踪维护和理解 8. 中介者模式（Mediator Pattern） 在中介者模式中，中介者（Mediator）包装了一系列对象相互作用的方式，使得这些对象不必直接相互作用，而是由中介者协调它们之间的交互，从而使它们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立的变化。 中介者模式和观察者模式有一定的相似性，都是一对多的关系，也都是集中式通信，不同的是中介者模式是处理同级对象之间的交互，而观察者模式是处理Observer和Subject之间的交互。中介者模式有些像婚恋中介，相亲对象刚开始并不能直接交流，而是要通过中介去筛选匹配再决定谁和谁见面。 场景 例如购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等等，都会触发change事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可。 123456789101112131415161718192021222324252627282930313233343536var goods = &#123; //手机库存 &#x27;red|32G&#x27;: 3, &#x27;red|64G&#x27;: 1, &#x27;blue|32G&#x27;: 7, &#x27;blue|32G&#x27;: 6,&#125;;//中介者var mediator = (function() &#123; var colorSelect = document.getElementById(&#x27;colorSelect&#x27;); var memorySelect = document.getElementById(&#x27;memorySelect&#x27;); var numSelect = document.getElementById(&#x27;numSelect&#x27;); return &#123; changed: function(obj) &#123; switch(obj)&#123; case colorSelect: //TODO break; case memorySelect: //TODO break; case numSelect: //TODO break; &#125; &#125; &#125;&#125;)();colorSelect.onchange = function() &#123; mediator.changed(this);&#125;;memorySelect.onchange = function() &#123; mediator.changed(this);&#125;;numSelect.onchange = function() &#123; mediator.changed(this);&#125;; 聊天室里 聊天室成员类： 123456789101112131415function Member(name) &#123; this.name = name; this.chatroom = null;&#125;Member.prototype = &#123; // 发送消息 send: function (message, toMember) &#123; this.chatroom.send(message, this, toMember); &#125;, // 接收消息 receive: function (message, fromMember) &#123; console.log(`$&#123;fromMember.name&#125; to $&#123;this.name&#125;: $&#123;message&#125;`); &#125;&#125; 聊天室类： 123456789101112131415function Chatroom() &#123; this.members = &#123;&#125;;&#125;Chatroom.prototype = &#123; // 增加成员 addMember: function (member) &#123; this.members[member.name] = member; member.chatroom = this; &#125;, // 发送消息 send: function (message, fromMember, toMember) &#123; toMember.receive(message, fromMember); &#125;&#125; 测试一下： 12345678910const chatroom = new Chatroom();const bruce = new Member(&#x27;bruce&#x27;);const frank = new Member(&#x27;frank&#x27;);chatroom.addMember(bruce);chatroom.addMember(frank);bruce.send(&#x27;Hey frank&#x27;, frank);//输出：bruce to frank: hello frank 优点 使各对象之间耦合松散，而且可以独立地改变它们之间的交互 中介者和对象一对多的关系取代了对象之间的网状多对多的关系 如果对象之间的复杂耦合度导致维护很困难，而且耦合度随项目变化增速很快，就需要中介者重构代码 缺点 系统中会新增一个中介者对象，因为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介 者对象自身往往就是一个难以维护的对象。 9. 访问者模式（Visitor Pattern） 访问者模式 是一种将算法与对象结构分离的设计模式，通俗点讲就是：访问者模式让我们能够在不改变一个对象结构的前提下能够给该对象增加新的逻辑，新增的逻辑保存在一个独立的访问者对象中。访问者模式常用于拓展一些第三方的库和工具。 12345678910111213141516171819202122// 访问者 class Visitor &#123; constructor() &#123;&#125; visitConcreteElement(ConcreteElement) &#123; ConcreteElement.operation() &#125;&#125;// 元素类 class ConcreteElement&#123; constructor() &#123; &#125; operation() &#123; console.log(&quot;ConcreteElement.operation invoked&quot;); &#125; accept(visitor) &#123; visitor.visitConcreteElement(this) &#125;&#125;// clientlet visitor = new Visitor()let element = new ConcreteElement()elementA.accept(visitor) 访问者模式的实现有以下几个要素： Visitor Object：访问者对象，拥有一个visit()方法 Receiving Object：接收对象，拥有一个 accept() 方法 visit(receivingObj)：用于Visitor接收一个Receiving Object accept(visitor)：用于Receving Object接收一个Visitor，并通过调用Visitor的 visit() 为其提供获取Receiving Object数据的能力 简单的代码实现如下： 123456789101112131415161718192021222324252627Receiving Object：function Employee(name, salary) &#123; this.name = name; this.salary = salary;&#125;Employee.prototype = &#123; getSalary: function () &#123; return this.salary; &#125;, setSalary: function (salary) &#123; this.salary = salary; &#125;, accept: function (visitor) &#123; visitor.visit(this); &#125;&#125;Visitor Object：function Visitor() &#123; &#125;Visitor.prototype = &#123; visit: function (employee) &#123; employee.setSalary(employee.getSalary() * 2); &#125;&#125; 验证一下： 12345const employee = new Employee(&#x27;bruce&#x27;, 1000);const visitor = new Visitor();employee.accept(visitor);console.log(employee.getSalary());//输出：2000 场景 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。 优点 符合单一职责原则 优秀的扩展性 灵活性 缺点 具体元素对访问者公布细节，违反了迪米特原则 违反了依赖倒置原则，依赖了具体类，没有依赖抽象。 具体元素变更比较困难 补充：Web前端面试 - 面试官系列Vue@V.2.6.11 源码解析Vue3 源码解析mini-vue 源码解析(vue3) 参考资料： 《66条恐怖如斯的 4W 字 JavaScript 面试知识点》","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"Javascript","slug":"Javascript","permalink":"http://example.com/tags/Javascript/"}]},{"title":"记录vue和D3处理穿透图","slug":"记录vue和D3处理穿透图","date":"2021-04-06T08:19:18.000Z","updated":"2021-04-07T06:17:37.333Z","comments":true,"path":"2021/04/06/记录vue和D3处理穿透图/","link":"","permalink":"http://example.com/2021/04/06/%E8%AE%B0%E5%BD%95vue%E5%92%8CD3%E5%A4%84%E7%90%86%E7%A9%BF%E9%80%8F%E5%9B%BE/","excerpt":"使用场景 团队需要使用展示一个穿透图，根据需求选择使用D3搭配vue来实现。 想要快速搭出一个模板，以确定是否可以使用。 有另存为(图片)的需求 版本选择 项目使用vue2.0的版本，本身项目是基于2.0, 未做升级。 选择D3的时候，就遇到了坑，现在最新的版本是6.xx, 而之前看的一些demo 基本上都是4.0 左右的版本，使用最新版本的时候，版本不同，调用Api的方式也不一样，导致很多报错。最后选择了5.16.0 , 5.xx的最后一个版本。","text":"使用场景 团队需要使用展示一个穿透图，根据需求选择使用D3搭配vue来实现。 想要快速搭出一个模板，以确定是否可以使用。 有另存为(图片)的需求 版本选择 项目使用vue2.0的版本，本身项目是基于2.0, 未做升级。 选择D3的时候，就遇到了坑，现在最新的版本是6.xx, 而之前看的一些demo 基本上都是4.0 左右的版本，使用最新版本的时候，版本不同，调用Api的方式也不一样，导致很多报错。最后选择了5.16.0 , 5.xx的最后一个版本。 Api的调用 Api文档 常用的Api： d3.select – 从文档中选取一个元素. d3.zoom – 创建一个缩放交互 zoom.scaleExtent – 设置可缩放系数大小. d3.hierarchy – 从给定的层次结构数据构造一个根节点并为各个节点指定深度等属性. transition.remove – 在过渡结束后移除选中的元素. transform.translate – 根据指定的值平移当前坐标变换. selection.selectAll -从每个被选中的元素中选择多个后代元素. tree.nodeSize – 设置节点尺寸. selection.data – 将元素与数据绑定. selection.enter – 获取需要插入的选择集(数据个数大于元素个数)的占位符. selection.exit – 获取多余的元素的选择集(数据个数小于元素个数). selection.on – 添加或移除事件监听器. selection.attr – 设置或获取属性. selection.style – 获取或设置样式属性. selection.text – 设置或获取文本内容. selection.append – 创建、添加并返回一个新的元素. selection.insert – 创建、插入并返回一个新的元素. selection.remove – 从文档中移除元素. SVG D3用来调试调试很方便，生成的路径在dom元素上展示的很清晰。 另存为图片： SVG —&gt; png 需要canvas 在中间进行转化 使用save-svg-as-png 插件 在保存图片的时候，svg的元素是大于屏幕范围的，这样的话通过canvas绘制的图片，只会展示屏幕显示的一部分。 通过getBBox()方法，获取最小矩形的坐标 保存的时候需要展开所有节点","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"D3","slug":"D3","permalink":"http://example.com/tags/D3/"}]},{"title":"Vue页面优化","slug":"Vue页面优化","date":"2021-04-01T02:57:23.000Z","updated":"2021-04-07T06:15:59.479Z","comments":true,"path":"2021/04/01/Vue页面优化/","link":"","permalink":"http://example.com/2021/04/01/Vue%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96/","excerpt":"页面载入进度条 nprogress 安装 1npm install --save nprogress 或 yarn add nprogress 使用 :12345678910import NProgress from &#39;nprogress&#39; &#x2F;&#x2F; 引入nprogress插件import &#39;nprogress&#x2F;nprogress.css&#39; &#x2F;&#x2F; 这个nprogress样式必须引入router.beforeEach(() &#x3D;&gt; &#123; NProgress.start();&#125;);router.afterEach(() &#x3D;&gt; &#123; NProgress.done();&#125;);","text":"页面载入进度条 nprogress 安装 1npm install --save nprogress 或 yarn add nprogress 使用 :12345678910import NProgress from &#39;nprogress&#39; &#x2F;&#x2F; 引入nprogress插件import &#39;nprogress&#x2F;nprogress.css&#39; &#x2F;&#x2F; 这个nprogress样式必须引入router.beforeEach(() &#x3D;&gt; &#123; NProgress.start();&#125;);router.afterEach(() &#x3D;&gt; &#123; NProgress.done();&#125;); 滚动条美化12345678910111213141516171819202122232425::-webkit-scrollbar &#123; width: 6px; height: 6px;&#125;::-webkit-scrollbar-track &#123; width: 6px; background: rgba(#101F1C, 0.1); -webkit-border-radius: 2em; -moz-border-radius: 2em; border-radius: 2em;&#125;::-webkit-scrollbar-thumb &#123; background-color: rgba(#101F1C, 0.5); background-clip: padding-box; min-height: 28px; -webkit-border-radius: 2em; -moz-border-radius: 2em; border-radius: 2em;&#125;::-webkit-scrollbar-thumb:hover &#123; background-color: rgba(#101F1C, 1);&#125; 移动端（高度） 100vh === 视口高度 ??? 并不是， 实际上在移动端 100vh === 视口高度 + 浏览器工具栏（地址栏等等）的高度 解决方案： 安装 vh-check npm install vh-check --save12import vhCheck from &#x27;vh-check&#x27;;vhCheck(&#x27;browser-address-bar&#x27;); 定义 CSS Mixin1234@mixin vh($height: 100vh) &#123; height: $height; height: calc(#&#123;$height&#125; - var(--browser-address-bar, 0px));&#125; 全局样式 variable.scss: 全局变量管理 mixins.scss: 全局 Mixins 管理 global.scss: 全局样式 其中 variable.scss 和 mixins.scss 会优先于 global.css 加载12345678910111213// vue.config.jsmodule.exports = &#123; css: &#123; loaderOptions: &#123; sass: &#123; prependData: ` @import &#x27;@/styles/variable.scss&#x27;; @import &#x27;@/styles/mixins.scss&#x27;; `, &#125;, &#125;, &#125;,&#125; 组件库 按需加载 Ant Design Vue 的组件样式1234567// babel.config.jsmodule.exports = &#123; presets: [&#x27;@vue/app&#x27;], // presets: [&#x27;@vue/cli-plugin-babel/preset&#x27;], plugins: [[&#x27;import&#x27;, &#123; libraryName: &#x27;ant-design-vue&#x27;, libraryDirectory: &#x27;es&#x27;, style: true &#125;]]&#125; 去掉无用的图标 创建icons.js 文件来管理Ant Design Vue图标12&#x2F;&#x2F; @&#x2F;src&#x2F;assets&#x2F;icons.jsexport &#123; default as LoadingOutline &#125; from &#39;@ant-design&#x2F;icons&#x2F;lib&#x2F;outline&#x2F;LoadingOutline&#39;; 配置vue.config.js 引入文件12345678910// vue.config.jsmodule.exports = &#123; configureWebpack: &#123; resolve: &#123; alias: &#123; &#x27;@ant-design/icons/lib/dist$&#x27;: path.resolve(__dirname, &#x27;./src/assets/icons.js&#x27;), &#125;, &#125;,&#125;,&#125; Moment 多国语, 只保留 zh-cn 语言包12345678// vue.config.jsmodule.exports = &#123; chainWebpack: (config) =&gt; &#123; config .plugin(&#x27;ContextReplacementPlugin&#x27;) .use(webpack.ContextReplacementPlugin, [/moment[/]locale$/, /zh-cn/]); &#125;,&#125; icon （雪碧图） 自动注册 Svg 图标，首先需要对 @/assets/icons 文件夹下的 svg 图标进行自动注册，需要对 webpack 和 svg-sprite-loader 进行了相关设置，文件全部打包成 svg-sprite。 12345678910111213141516module.exports = &#123; chainWebpack: (config) =&gt; &#123; config.module .rule(&#x27;svg&#x27;) .exclude.add(resolve(&#x27;src/assets/icons&#x27;)) .end(); config.module .rule(&#x27;icons&#x27;) .test(/.svg$/) .include.add(resolve(&#x27;src/assets/icons&#x27;)) .end() .use(&#x27;svg-sprite-loader&#x27;) .loader(&#x27;svg-sprite-loader&#x27;); &#125;,&#125; 写一个全局用的 Vue 组件 : 1234// @/components/m-svg/index.jsconst requireAll = (requireContext) =&gt; requireContext.keys().map(requireContext);const req = require.context(&#x27;@/assets/icons&#x27;, false, /.svg$/);requireAll(req); 1234567891011121314151617181920212223242526272829@/components/m-svg/index.vue&lt;template&gt; &lt;svg class=&quot;mw-svg&quot; aria-hidden=&quot;true&quot;&gt; &lt;use :xlink:href=&quot;iconName&quot;&gt;&lt;/use&gt; &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;m-svg&#x27;, props: &#123; name: &#123; type: String, default: &#x27;&#x27; &#125;, &#125;, computed: &#123; iconName() &#123; return `#$&#123;this.name&#125;`; &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.mw-svg &#123; width: 1.4em; height: 1.4em; fill: currentColor; overflow: hidden; line-height: 1em; display: inline-block;&#125;&lt;/style&gt; 参数 name 类型：String 默认值：null 说明：放置在 @/assets/icons 文件夹下的文件名 样式 图标的大小可以通过 width + height 属性改变。 通过改变 font-size 属性改变，宽高 = font-zise * 1.4 跨域问题12345678910111213&#x2F;&#x2F; vue.config.jsdevServer: &#123; proxy: &#123; &#39;&#x2F;api&#39;: &#123; target: &#39;http:&#x2F;&#x2F;47.100.186.132&#x2F;your-path&#x2F;api&#39;, ws: true, changeOrigin: true, pathRewrite: &#123; &#39;^&#x2F;api&#39;: &#39;&#39; &#125; &#125; &#125;&#125; 路由 Layout frameIn：基于 BasicLayout，通常需要登录或权限认证的路由。 frameOut：不需要动态判断权限的路由，如登录页或通用页面。 errorPage：例如404。 权限验证, 通过获取当前用户的权限去比对路由表，生成当前用户具的权限可访问的路由表，通过 router.addRoutes 动态挂载到 router 上。 判断页面是否需要登陆状态，需要则跳转到 /user/login 本地存储中不存在 token 则跳转到 /user/login 如果存在 token，用户信息不存在，自动调用 vuex ‘/system/user/getInfo’ 在路由中，集成了权限验证的功能，需要为页面增加权限时，在 meta 下添加相应的 key: auth 类型：Boolean 说明：当 auth 为 true 时，此页面需要进行登陆权限验证，只针对 frameIn 路由有效。 permissions 类型：Object 说明：permissions 每一个 key 对应权限功能的验证，当 key 的值为 true 时，代表具有权限，若 key 为 false，配合 v-permission 指令，可以隐藏相应的 DOM。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import router from &#x27;@/router&#x27;;import store from &#x27;@/store&#x27;;import storage from &#x27;store&#x27;;import util from &#x27;@/libs/utils&#x27;;// 进度条import NProgress from &#x27;nprogress&#x27;;import &#x27;nprogress/nprogress.css&#x27;;const loginRoutePath = &#x27;/user/login&#x27;;const defaultRoutePath = &#x27;/home&#x27;;/** * 路由拦截 * 权限验证 */router.beforeEach(async (to, from, next) =&gt; &#123; // 进度条 NProgress.start(); // 验证当前路由所有的匹配中是否需要有登录验证的 if (to.matched.some((r) =&gt; r.meta.auth)) &#123; // 是否存有token作为验证是否登录的条件 const token = storage.get(&#x27;ACCESS_TOKEN&#x27;); if (token &amp;&amp; token !== &#x27;undefined&#x27;) &#123; // 是否处于登录页面 if (to.path === loginRoutePath) &#123; next(&#123; path: defaultRoutePath &#125;); // 查询是否储存用户信息 &#125; else if (Object.keys(store.state.system.user.info).length === 0) &#123; store.dispatch(&#x27;system/user/getInfo&#x27;).then(() =&gt; &#123; next(); &#125;); &#125; else &#123; next(); &#125; &#125; else &#123; // 没有登录的时候跳转到登录界面 // 携带上登陆成功之后需要跳转的页面完整路径 next(&#123; name: &#x27;Login&#x27;, query: &#123; redirect: to.fullPath, &#125;, &#125;); NProgress.done(); &#125; &#125; else &#123; // 不需要身份校验 直接通过 next(); &#125;&#125;);router.afterEach((to) =&gt; &#123; // 进度条 NProgress.done(); util.title(to.meta.title);&#125;); 构建优化 包分析工具1234567891011const WebpackBundleAnalyzer = require(&#x27;webpack-bundle-analyzer&#x27;);module.exports = &#123; chainWebpack: (config) =&gt; &#123; if (process.env.use_analyzer) &#123; config .plugin(&#x27;webpack-bundle-analyzer&#x27;) .use(WebpackBundleAnalyzer.BundleAnalyzerPlugin); &#125; &#125;,&#125;; 开启 Gzip12345chainWebpack: (config) =&gt; &#123; config .plugin(&#x27;CompressionPlugin&#x27;) .use(CompressionPlugin, []);&#125;, 路由懒加载1234567&#123; path: &#x27;home&#x27;, name: &#x27;Home&#x27;, component: () =&gt; import( /* webpackChunkName: &quot;home&quot; */ &#x27;@/views/home/index.vue&#x27; ),&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"工具 & 网站 & 资源","slug":"工具 & 网站 & 资源","date":"2021-03-31T08:46:34.000Z","updated":"2021-04-09T08:38:11.214Z","comments":true,"path":"2021/03/31/工具 & 网站 & 资源/","link":"","permalink":"http://example.com/2021/03/31/%E5%B7%A5%E5%85%B7%20&%20%E7%BD%91%E7%AB%99%20&%20%E8%B5%84%E6%BA%90/","excerpt":"工具集 codeIf 变量命名智能推荐（支持中文） Github地址","text":"工具集 codeIf 变量命名智能推荐（支持中文） Github地址 regexr 正则表达式验证匹配 官网 any-rule 正则表达式库 可以直接安装到Vscode Github地址 CSS Sprites Generato 多张图片合成雪碧图，并生成对应 css 官网 gitignore 根据选择会去生成 .gitignore 文件 官网 网站集 codesandbox 在线代码编辑器 官网 docschina 印象中文，为 Web 前端开发人员提供优质中文文档 官网 mdnice 使 markdown 语法更加美观 官网 Am I Responsive? 检查网站在不同屏幕尺寸下的外观 官网 jsrun.net / JSFiddle / CodePen 在线IDE服务 jsrun官网 JSFiddle官网 CodePen官网 资源集 javascript-algorithms 基于 JavaScript 的算法与数据结构 Github Youtube视频 nodebestpractices Node.js 最佳实践 Github You-Dont-Know-JS You Don’t Know JS 图书系列, 一系列深入探讨 JavaScript 语言核心机制的书籍 Github clean-code-javascript 优秀的 JS 代码规范 Github 30-seconds-of-code 开发需求的简短代码段（经典 js 代码片段） Github javascript JavaScript 编程风格指南 Github tech-interview-handbook 面试全流程， 常见的算法问题，面试备忘单 Github freeCodeCamp 自由开源的学习编程社区 Github CSLearning 开源项目之「计算机编程自学之路」（拱白菜的阿秀） Github Build Your Own X 汇集了诸多优质资源，教你如何构建一些属于自己的东西，内容主要分为增强现实、区块链、机器人、编辑器、命令行工具、神经网络、操作系统等几大类别。 Github free-programming-resources 免费编程资源大全 Github free-programming-books 免费编程书籍。收集了特别多免费的编程电子书、编程课程、播客、网站等学习资源。内容不仅包含编程语言电子书籍推荐，一些语言类目的资源依然精彩，比如版本控制、IDEA、设计模式等等。 Github","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"网站","slug":"网站","permalink":"http://example.com/tags/%E7%BD%91%E7%AB%99/"}]},{"title":"知白守黑","slug":"知白守黑","date":"2021-03-24T07:02:50.000Z","updated":"2021-03-24T09:35:42.422Z","comments":true,"path":"2021/03/24/知白守黑/","link":"","permalink":"http://example.com/2021/03/24/%E7%9F%A5%E7%99%BD%E5%AE%88%E9%BB%91/","excerpt":"知其白，守其黑，为天下式；","text":"知其白，守其黑，为天下式； 知其雄，守其雌，为天下谿；为天下谿，常德不离，复归于婴儿。知其白，守其黑，为天下式；为天下式，常德不忒，复归於无极。知其荣，守其辱，为天下谷；为天下谷，常德乃足，复归于朴。《道德经·第二十八章》","categories":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://example.com/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"三月的诗","slug":"三月的诗","date":"2021-03-23T07:58:30.000Z","updated":"2021-04-01T02:16:27.206Z","comments":true,"path":"2021/03/23/三月的诗/","link":"","permalink":"http://example.com/2021/03/23/%E4%B8%89%E6%9C%88%E7%9A%84%E8%AF%97/","excerpt":"孤山寺北贾亭西，水面初平云脚低。 几处早莺争暖树，谁家新燕啄春泥。 乱花渐欲迷人眼，浅草才能没马蹄。 最爱湖东行不足，绿杨阴里白沙堤。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——唐·白居易《钱塘湖春行》","text":"孤山寺北贾亭西，水面初平云脚低。 几处早莺争暖树，谁家新燕啄春泥。 乱花渐欲迷人眼，浅草才能没马蹄。 最爱湖东行不足，绿杨阴里白沙堤。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——唐·白居易《钱塘湖春行》 闻道春还未相识，走傍寒梅访消息。 昨夜东风入武阳，陌头杨柳黄金色。 碧水浩浩云茫茫，美人不来空断肠。 预拂青山一片石，与君连日醉壶觞。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——唐·李白《早春寄王汉阳 》","categories":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://example.com/tags/%E7%94%9F%E6%B4%BB/"},{"name":"诗句","slug":"诗句","permalink":"http://example.com/tags/%E8%AF%97%E5%8F%A5/"}]}],"categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"Javascript","slug":"Javascript","permalink":"http://example.com/tags/Javascript/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"D3","slug":"D3","permalink":"http://example.com/tags/D3/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"网站","slug":"网站","permalink":"http://example.com/tags/%E7%BD%91%E7%AB%99/"},{"name":"生活","slug":"生活","permalink":"http://example.com/tags/%E7%94%9F%E6%B4%BB/"},{"name":"诗句","slug":"诗句","permalink":"http://example.com/tags/%E8%AF%97%E5%8F%A5/"}]}